package com.inman.service;

import com.inman.entity.Item;
import com.inman.entity.OrderLineItem;
import com.inman.model.request.GenericSingleId;
import com.inman.model.request.OrderLineItemRequest;
import com.inman.model.response.ResponsePackage;
import com.inman.model.response.TextResponse;
import com.inman.model.rest.ErrorLine;
import com.inman.repository.ItemRepository;
import com.inman.repository.OrderLineItemRepository;
import enums.CrudAction;
import enums.OrderState;
import enums.OrderType;
import enums.SourcingType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;

import static java.lang.Math.abs;

@Service
public class AutomatedPlanningService {

    static Logger logger = LoggerFactory.getLogger(AutomatedPlanningService.class);
    private final ItemRepository itemRepository;
    private final OrderLineItemRepository orderLineItemRepository;
    private final OrderLineItemService orderLineItemService;

        private void outputErrorAndThrow(String message, ResponsePackage<?> responsePackage) {
        logger.info(message);
        responsePackage.getErrors().add(new ErrorLine(1, message));
        throw new RuntimeException(message);
    }

    @Autowired
    public AutomatedPlanningService(
                                    ItemRepository itemRepository,
                                    OrderLineItemRepository orderLineItemRepository,
                                    OrderLineItemService orderLineItemService) {


        this.itemRepository = itemRepository;
        this.orderLineItemRepository = orderLineItemRepository;
        this.orderLineItemService = orderLineItemService;
    }

    @Transactional
    public void basic( GenericSingleId genericSingleId, TextResponse textResponse) {
        ArrayList<OrderLineItem> newOrders = new ArrayList<>();
        List<Item> itemsToBePlanned;
        if ( genericSingleId.getIdToSearchFor() == -1 ) {
            itemsToBePlanned = itemRepository.findAllByOrderByMaxDepthAsc();
        } else {
            itemsToBePlanned = new ArrayList<>();
            Optional<Item> item = itemRepository.findById( genericSingleId.getIdToSearchFor() );
            if ( item.isPresent() ) {
                itemsToBePlanned.add( item.get() );
            } else {
                outputErrorAndThrow( "Item " + genericSingleId.getIdToSearchFor() + " not found", textResponse );
            }
        }

        for (Item item : itemsToBePlanned) {
            inventoryBalanceForItem(item, textResponse, newOrders);

            if ( item.getId() == 5 ) {
                logger.info( "Some 5 is coming");
            }

            List<OrderLineItem> consolidatedOrders = consolidateProposedChanges( newOrders, item );

            applyProposedChanges(consolidatedOrders );
        }
    }

    /**
     * Determine the item balance over time.  Optional propose new orders to ensure balance never falls
     * below zero and adheres to purchasing rules.
     *
     * @param item         to plan for.
     * @param textResponse to place messages and errors.
     * @param newOrders    optional container for orders generated by planning.
     */
    public void inventoryBalanceForItem(Item item, TextResponse textResponse, ArrayList<OrderLineItem> newOrders) {
        List<OrderLineItem> orders = orderLineItemRepository.findByItemIdAndOrderStateOrderByCompleteDate(item.getId(), OrderState.OPEN);
        double balance = item.getQuantityOnHand();
        if (!orders.isEmpty()) {
            textResponse.addText("", Optional.of(logger));
        }
        textResponse.addText("Inventory Analysis for " + item, Optional.of(logger));
        if (!orders.isEmpty()) {
                    textResponse.addText("Opening Balance of " + balance +
                    " and there are " + orders.size() + " open orders", Optional.of(logger));
            textResponse.addText(OrderLineItem.header + "  Balance", Optional.of(logger));
        }
        for (OrderLineItem order : orders) {
            balance += order.getEffectiveQuantityOrdered();
            textResponse.addText(String.format("%s %8.2f", order.toStringWithSignedQuantity(), balance), Optional.of(logger));
            balance = createNewOrderAsNeeded(item, textResponse, newOrders, order.getStartDate(), balance);
        }

    }

    /**
     * Optionally (if the new orders is non-null) create new order to ensure the balance stays above 0.
     *
     * @param item         which owns the order.
     * @param textResponse in/out overall response message.
     * @param newOrders    in/out collection of new orders if needed.  When null this function is a noop.
     * @param startDateOfParentOrder        Make sure that this component supply arrives before the order starts.
     * @param balance      current balance after applying all orders.
     * @return updated balance from any newly created orders.
     */
    private double createNewOrderAsNeeded(Item item, TextResponse textResponse, ArrayList<OrderLineItem> newOrders, String startDateOfParentOrder, double balance) {

        if (newOrders == null || balance >= 0.0 ) {
            return balance;
        }

        OrderLineItem newOrder = new OrderLineItem();

        newOrder.setCrudAction(CrudAction.INSERT);
        newOrder.setItemId(item.getId());
        newOrder.setQuantityOrdered( abs(balance) );
        newOrder.setStartDate(null);
        newOrder.setCompleteDate(startDateOfParentOrder);
        newOrder.setParentOliId(0L);
        newOrder.setOrderState(OrderState.OPEN);
        newOrder.setOrderType(item.getSourcing() == SourcingType.MAN ? OrderType.MOHEAD : OrderType.PO);
        newOrders.add(newOrder);
        balance = newOrder.getEffectiveQuantityOrdered() + balance;
        textResponse.addText(String.format("%s %8.2f", newOrder.toStringWithSignedQuantity(), balance), Optional.of(logger));
        return balance;
    }


    private void applyProposedChanges(List<OrderLineItem> orders) {

        OrderLineItemRequest crudBatch = new OrderLineItemRequest(orders.toArray(new OrderLineItem[0]));
        ResponsePackage<OrderLineItem> responsePackage = new ResponsePackage<>();

        orderLineItemService.applyCrud(crudBatch, responsePackage);

        if (!responsePackage.getErrors().isEmpty()) {
            logger.info("Messages when trying to create orders: ");
            for (ErrorLine error : responsePackage.getErrors()) {
                logger.info( "-" + error.getMessage());
            }
        }
    }

    private List<OrderLineItem> consolidateProposedChanges( Collection<OrderLineItem> orders, Item item ) {
        MultiValueMap<String,OrderLineItem> proposedChanges = new LinkedMultiValueMap<>();

        for (OrderLineItem order : orders) {
            if ( order.getOrderType() == OrderType.PO ) {
                proposedChanges.add(order.getCompleteDate(), order);
            }
        }

        List<OrderLineItem> consolidatedOrders = new ArrayList<>();

        for ( String completedDate : proposedChanges.keySet()  ) {
            List<OrderLineItem> ordersWithSameCompletedDate = proposedChanges.get( completedDate );

            double orderQuantity = 0.0;
            OrderLineItem consolidatedOrderLine = new OrderLineItem( ordersWithSameCompletedDate.get( 0 ) );
            consolidatedOrderLine.setQuantityOrdered( 0.0f );


            for ( OrderLineItem oneOfTheOrdersOnCompletionDate : ordersWithSameCompletedDate ) {
                orderQuantity += oneOfTheOrdersOnCompletionDate.getQuantityOrdered();
                logger.info( "  oneOfTheOrders " + oneOfTheOrdersOnCompletionDate );
            }
            orderQuantity = item.applyOrderQuantityRules( orderQuantity );
            consolidatedOrderLine.setQuantityOrdered( orderQuantity );
            consolidatedOrders.add( consolidatedOrderLine );
            logger.info( "Final Consolidated Order " + consolidatedOrderLine );
        }
        return consolidatedOrders;
    }

//    private void calculateMaxDepths(TextResponse textResponse) {
//        outputInfo("Resetting max depth...", textResponse);
//
//        var numberOfResets = ddlRepository.resetMaxDepth();
//
//        ArrayList<Text> texts = new ArrayList<>();
//        textResponse.addText(numberOfResets + " items were reset", Optional.of(logger));
//
//        List<Item> items = itemRepository.findAll();
//
//        for (Item item : items) {
//            logger.info("Processing item {}:{}", item.getId(), item.getSummaryId());
//            bomLogicService.updateMaxDepthOf(item.getId(), texts);
//        }
//    }

    public void inventoryBalanceProjection(GenericSingleId genericSingleId, TextResponse textResponse) {

        Item[] items;
        if (genericSingleId.getIdToSearchFor() < 0) {
            items = itemRepository.itemsByDepthAndId();
        } else {
            items = new Item[1];
            Optional<Item> singleItem = itemRepository.findById(genericSingleId.getIdToSearchFor());
            if (singleItem.isEmpty() ) {
                outputErrorAndThrow("ItemId " + genericSingleId.getIdToSearchFor() + " not found ", textResponse);
            }
            items[ 0 ] = singleItem.get();
        }
        for (Item item : items) {
            inventoryBalanceForItem(item, textResponse, null);
            if ( items.length > 1 ) {
                textResponse.addText( "", Optional.of(logger)) ;
            }
        }
    }

}


