package com.inman.service;

import com.inman.entity.*;
import com.inman.model.request.GenericSingleId;
import com.inman.model.request.OrderLineItemRequest;
import com.inman.model.response.ResponsePackage;
import com.inman.model.response.TextResponse;
import com.inman.model.rest.ErrorLine;
import com.inman.repository.*;
import enums.CrudAction;
import enums.OrderState;
import enums.OrderType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static java.lang.Double.max;
import static java.lang.Math.abs;

@Service
public class AutomatedPlanningService {

    static Logger logger = LoggerFactory.getLogger(AutomatedPlanningService.class);
    private final ItemRepository itemRepository;
    private final DdlRepository ddlRepository;
    private final BomLogicService bomLogicService;
    private final OrderLineItemRepository orderLineItemRepository;
    private final OrderLineItemService orderLineItemService;

    private void outputInfo(String message, ResponsePackage<?> responsePackage) {
        logger.info(message);
        responsePackage.getErrors().add(new ErrorLine(1, message));
    }

    private void outputErrorAndThrow(String message, ResponsePackage<?> responsePackage) {
        logger.info(message);
        responsePackage.getErrors().add(new ErrorLine(1, message));
        throw new RuntimeException(message);
    }

    @Autowired
    public AutomatedPlanningService(DdlRepository ddlRepository,
                                    BomLogicService bomLogicService, ItemRepository itemRepository,
                                    OrderLineItemRepository orderLineItemRepository,
                                    OrderLineItemService orderLineItemService) {
        this.ddlRepository = ddlRepository;
        this.bomLogicService = bomLogicService;
        this.itemRepository = itemRepository;
        this.orderLineItemRepository = orderLineItemRepository;
        this.orderLineItemService = orderLineItemService;
    }

    @Transactional
    public void basic( GenericSingleId genericSingleId, TextResponse textResponse) {
        ArrayList<OrderLineItem> newOrders = new ArrayList<>();
        List<Item> itemsToBePlanned;
        if ( genericSingleId.getIdToSearchFor() == -1 ) {
            itemsToBePlanned = itemRepository.findAllByOrderByMaxDepthAsc();
        } else {
            itemsToBePlanned = new ArrayList<>();
            Optional<Item> item = itemRepository.findById( genericSingleId.getIdToSearchFor() );
            if ( item.isPresent() ) {

                itemsToBePlanned.add( item.get() );
            } else {
                outputErrorAndThrow( "Item " + genericSingleId.getIdToSearchFor() + " not found", textResponse );
            }
        }

        for (Item item : itemsToBePlanned) {
            inventoryBalanceForItem(item, textResponse, newOrders);
            applyProposedChanges(newOrders);
        }
    }

    /**
     * Determine the item balance over time.  Optional propose new orders to ensure balance never falls
     * below zero and adheres to purchasing rules.
     *
     * @param item         to plan for.
     * @param textResponse to place messages and errors.
     * @param newOrders    optional container for orders generated by planning.
     */
    public void inventoryBalanceForItem(Item item, TextResponse textResponse, ArrayList<OrderLineItem> newOrders) {
        List<OrderLineItem> orders = orderLineItemRepository.findByItemIdAndOrderStateOrderByCompleteDate(item.getId(), OrderState.OPEN);
        double balance = item.getQuantityOnHand();
        if ( orders.size() > 0 ) {
            textResponse.addText("", Optional.of(logger));
        }
        textResponse.addText("Inventory Analysis for " + item, Optional.of(logger));
        if ( orders.size() > 0 ) {
                    textResponse.addText("Opening Balance of " + balance +
                    " and there are " + orders.size() + " open orders", Optional.of(logger));
            textResponse.addText(OrderLineItem.header + "  Balance", Optional.of(logger));
        }
        for (OrderLineItem order : orders) {
            balance += order.getEffectiveQuantityOrdered();
            textResponse.addText(String.format("%s %8.2f", order.toStringWithSignedQuantity(), balance), Optional.of(logger));
            balance = createNewOrderAsNeeded(item, textResponse, newOrders, order.getStartDate(), balance);
        }

    }

    /**
     * Optionally (if the new orders is non-null) create new order to ensure the balance stays above 0.
     *
     * @param item         which owns the order.
     * @param textResponse in/out overall response message.
     * @param newOrders    in/out collection of new orders if needed.  When null this function is a noop.
     * @param startDateOfParentOrder        Make sure that this component supply arrives before the order starts.
     * @param balance      current balance after applying all orders.
     * @return updated balance from any newly created orders.
     */
    private double createNewOrderAsNeeded(Item item, TextResponse textResponse, ArrayList<OrderLineItem> newOrders, String startDateOfParentOrder, double balance ) {
        double balanceAfterOrder = balance;
        if (newOrders != null && balance < 0) {
            OrderLineItem newOrder = new OrderLineItem();

            newOrder.setCrudAction(CrudAction.INSERT);
            newOrder.setItemId(item.getId());
            newOrder.setQuantityOrdered(max(item.getMinimumOrderQuantity(), abs(balance)));
            newOrder.setStartDate(null);
            newOrder.setCompleteDate( startDateOfParentOrder );
            newOrder.setParentOliId( 0L );
            newOrder.setOrderState( OrderState.OPEN );
            newOrder.setOrderType(item.getSourcing().equals(Item.SOURCE_MAN) ? OrderType.MOHEAD : OrderType.PO);

            newOrders.add(newOrder);
            balanceAfterOrder = newOrder.getEffectiveQuantityOrdered() + balance;
            textResponse.addText(String.format("%s %8.2f", newOrder.toStringWithSignedQuantity(), balanceAfterOrder), Optional.of(logger));
        }
        return balanceAfterOrder;
    }


    private void applyProposedChanges(List<OrderLineItem> orders) {

        OrderLineItemRequest crudBatch = new OrderLineItemRequest(orders.toArray(new OrderLineItem[0]));
        ResponsePackage<OrderLineItem> responsePackage = new ResponsePackage<>();

        orderLineItemService.applyCrud(crudBatch, responsePackage);

        if ( responsePackage.getErrors().size() > 0  ) {
        logger.info("errors reported when trying to create orders: ");
        for (ErrorLine error : responsePackage.getErrors()) {
            logger.info(error.getMessage());
        }
        }
    }

    private void calculateMaxDepths(TextResponse textResponse) {
        outputInfo("Resetting max depth...", textResponse);

        var numberOfResets = ddlRepository.resetMaxDepth();

        ArrayList<Text> texts = new ArrayList<>();
        textResponse.addText(numberOfResets + " items were reset", Optional.of(logger));

        List<Item> items = itemRepository.findAll();

        for (Item item : items) {
            logger.info("Processing item {}:{}", item.getId(), item.getSummaryId());
            bomLogicService.updateMaxDepthOf(item.getId(), texts);
        }
    }

    public void inventoryBalanceProjection(GenericSingleId genericSingleId, TextResponse textResponse) {

        Item[] items;
        if (genericSingleId.getIdToSearchFor() < 0) {
            items = itemRepository.itemsByDepthAndId();
        } else {
            items = new Item[1];
            Optional<Item> singleItem = itemRepository.findById(genericSingleId.getIdToSearchFor());
            if (singleItem.isEmpty() ) {
                outputErrorAndThrow("ItemId " + genericSingleId.getIdToSearchFor() + " not found ", textResponse);
            }
            items[ 0 ] = singleItem.get();
        }
        for (Item item : items) {
            inventoryBalanceForItem(item, textResponse, null);
            if ( items.length > 1 ) {
                textResponse.addText( "", Optional.of(logger)) ;
            }
        }
    }

}


