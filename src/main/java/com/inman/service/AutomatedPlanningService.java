package com.inman.service;

import com.inman.entity.Item;
import com.inman.entity.OrderLineItem;
import com.inman.entity.Text;
import com.inman.model.request.GenericSingleId;
import com.inman.model.request.OrderLineItemRequest;
import com.inman.model.response.ResponsePackage;
import com.inman.model.response.TextResponse;
import com.inman.model.rest.ErrorLine;
import com.inman.repository.DdlRepository;
import com.inman.repository.ItemRepository;
import com.inman.repository.OrderLineItemRepository;
import enums.CrudAction;
import enums.OrderState;
import enums.OrderType;
import enums.SourcingType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.util.Pair;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;

import static com.inman.controller.LoggingUtility.outputInfo;
import static com.inman.controller.Messages.ITEM_REF_NOT_FOUND;
import static com.inman.controller.Utility.*;
import static java.lang.Math.abs;

@Service
public class AutomatedPlanningService {

    static Logger logger = LoggerFactory.getLogger(AutomatedPlanningService.class);
    private final ItemRepository itemRepository;
    private final OrderLineItemRepository orderLineItemRepository;
    private final DdlRepository ddlRepository;
    private final OrderLineItemService orderLineItemService;
    private final BomLogicService bomLogicService;

    @Autowired
    public AutomatedPlanningService(
                                    ItemRepository itemRepository,
                                    OrderLineItemRepository orderLineItemRepository,
                                    OrderLineItemService orderLineItemService,
                                    DdlRepository ddlRepository,
                                    BomLogicService bomLogicService) {


        this.itemRepository = itemRepository;
        this.orderLineItemRepository = orderLineItemRepository;
        this.orderLineItemService = orderLineItemService;
        this.ddlRepository = ddlRepository;
        this.bomLogicService = bomLogicService;
    }

    @Transactional
    public void basic( GenericSingleId genericSingleId, TextResponse textResponse) {

        List<Item> itemsToBePlanned;
        if ( genericSingleId.idToSearchFor() == -1 ) {
            //  calculateMaxDepths( textResponse );
            itemsToBePlanned = itemRepository.findAllByOrderByMaxDepthAsc();
        } else {
            itemsToBePlanned = new ArrayList<>();
            Optional<Item> item = Optional.ofNullable(itemRepository.findById(genericSingleId.idToSearchFor()));
            if ( item.isPresent() ) {
                itemsToBePlanned.add( item.get() );
            } else {
                outputErrorAndThrow( ITEM_REF_NOT_FOUND.formatted( "Item Id Parameter", genericSingleId.idToSearchFor() ),
                        textResponse, logger );
            }
        }

        for (Item item : itemsToBePlanned) {
            ArrayList<OrderLineItem> newOrders = new ArrayList<>();
            inventoryBalanceForItem(item, textResponse, newOrders);

            if (!newOrders.isEmpty()) {
                if ( normalize( genericSingleId.options() ).length() != 0 )  {
                    applyProposedChanges(newOrders);
                } else {
                    List<OrderLineItem> consolidatedOrders = consolidateProposedChanges(newOrders, item);
                    applyProposedChanges(consolidatedOrders);
                }
            }
        }
    }

    /**
     * Determine the item balance over time.  Optional propose new orders to ensure balance never falls
     * below zero and adheres to purchasing rules.
     *
     * @param item         to plan for.
     * @param textResponse to place messages and errors.
     * @param newOrders    optional container for orders generated by planning.
     */
    public void inventoryBalanceForItem(Item item, TextResponse textResponse, ArrayList<OrderLineItem> newOrders) {
        List<OrderLineItem> orders = orderLineItemRepository.findByItemIdAndOrderStateOrderByCompleteDate(item.getId(), OrderState.OPEN);

        double balance = item.getQuantityOnHand();
        if (!orders.isEmpty()) {
            textResponse.addText("", Optional.of(logger));
        }
        textResponse.addText("Inventory Analysis for " + item, Optional.of(logger));
        if (!orders.isEmpty()) {
                    textResponse.addText("Opening Balance of " + balance +
                    " and there are " + orders.size() + " open orders", Optional.of(logger));
            textResponse.addText(OrderLineItem.header + "  Balance", Optional.of(logger));
        }


        for (OrderLineItem order : orders) {
            balance += order.getEffectiveQuantityOrdered();
            textResponse.addText(String.format("%s %8.2f", order.toStringWithSignedQuantity(), balance), Optional.of(logger));
            balance = createNewOrderAsNeeded(item, textResponse, newOrders, order.getStartDate(), balance);
        }

    }

    /**
     * Refactored method.
     * This method now calls the new helper method createOrderAndUpdateBalance.
     */
    private double createNewOrderAsNeeded(Item item, TextResponse textResponse,
                                          ArrayList<OrderLineItem> newOrders,
                                          String startDateOfParentOrder, double balance) {
        if (newOrders == null || balance >= 0.0) {
            return balance;
        }

        var result = createOrderAndUpdateBalance(item, startDateOfParentOrder, balance);
        OrderLineItem newOrder = result.getFirst();
        balance = result.getSecond();
        newOrders.add(newOrder);
        textResponse.addText(String.format("%s %8.2f", newOrder.toStringWithSignedQuantity(), balance), Optional.of(logger));
        return balance;
    }

    // This is a new helper method that we extract from the original one.
    private Pair<OrderLineItem, Double> createOrderAndUpdateBalance(Item item,
                                                                    String startDateOfParentOrder,
                                                                    double balance) {
        OrderLineItem newOrder = new OrderLineItem();
        newOrder.setCrudAction(CrudAction.INSERT);
        newOrder.setItemId(item.getId());
        newOrder.setQuantityOrdered(abs(balance));
        newOrder.setStartDate(null);
        newOrder.setCompleteDate(startDateOfParentOrder);
        newOrder.setParentOliId(0L);
        newOrder.setOrderState(OrderState.OPEN);
        newOrder.setOrderType(item.getSourcing() == SourcingType.MAN ? OrderType.MOHEAD : OrderType.PO);
        balance = newOrder.getEffectiveQuantityOrdered() + balance;
        return Pair.of( newOrder, balance);
    }


    private void applyProposedChanges(List<OrderLineItem> orders) {

        OrderLineItemRequest crudBatch = new OrderLineItemRequest(orders.toArray(new OrderLineItem[0]));
        ResponsePackage<OrderLineItem> responsePackage = new ResponsePackage<>();

        try {
            orderLineItemService.applyCrud(crudBatch, responsePackage);
        } catch (Exception e) {
            logger.error("Error applying proposed changes: %s".formatted(e.getMessage()));
        }

        if (!responsePackage.getErrors().isEmpty()) {
            logger.info("Messages when trying to create orders: ");
            for (ErrorLine error : responsePackage.getErrors()) {
                logger.info("-%s".formatted(error.getMessage()));
            }
        }
    }

    private List<OrderLineItem> consolidateProposedChanges( Collection<OrderLineItem> orders, Item item ) {
        MultiValueMap<String,OrderLineItem> proposedChanges = new LinkedMultiValueMap<>();

        for (OrderLineItem order : orders) {
            if ( order.getOrderType() == OrderType.PO
            || order.getOrderType() == OrderType.MOHEAD ) {
                proposedChanges.add(order.getCompleteDate(), order);
            }
        }

        List<OrderLineItem> consolidatedOrders = new ArrayList<>();

        for ( String completedDate : proposedChanges.keySet()  ) {
            List<OrderLineItem> ordersWithSameCompletedDate = proposedChanges.get( completedDate );

            double orderQuantity = 0.0;
            OrderLineItem consolidatedOrderLine = new OrderLineItem( ordersWithSameCompletedDate.get( 0 ) );
            consolidatedOrderLine.setQuantityOrdered( 0.0f );

            for ( OrderLineItem oneOfTheOrdersOnCompletionDate : ordersWithSameCompletedDate ) {
                orderQuantity += oneOfTheOrdersOnCompletionDate.getQuantityOrdered();
            }
            orderQuantity = item.applyOrderQuantityRules( orderQuantity );
            consolidatedOrderLine.setQuantityOrdered( orderQuantity );
            consolidatedOrders.add( consolidatedOrderLine );
        }
        return consolidatedOrders;
    }

    private void calculateMaxDepths(TextResponse textResponse) {
        outputInfo("Resetting max depth", textResponse, logger );

        var numberOfResets = ddlRepository.resetMaxDepth();

        ArrayList<Text> texts = new ArrayList<>();
        textResponse.addText(numberOfResets + " items were reset", Optional.of(logger));

        List<Item> items = itemRepository.findAll();

        for (Item item : items) {
            logger.info("Processing item {}:{}", item.getId(), item.getDescription());
            bomLogicService.updateMaxDepthOf(item.getId(), texts);
        }
    }

    public void inventoryBalanceProjection(GenericSingleId genericSingleId, TextResponse textResponse) {

        Item[] items;
        if (genericSingleId.idToSearchFor() < 0) {
            items = itemRepository.itemsByDepthAndId();
        } else {
            items = new Item[1];
            Optional<Item> singleItem = Optional.ofNullable(itemRepository.findById(genericSingleId.idToSearchFor()));
            if (singleItem.isEmpty() ) {
                outputErrorAndThrow( ITEM_REF_NOT_FOUND.formatted( "IBP Parameter", genericSingleId.idToSearchFor() ),
                        textResponse, logger);
                return;
            }
            items[ 0 ] = singleItem.get();
        }
        for (Item item : items) {
            inventoryBalanceForItem(item, textResponse, null);
            if ( items.length > 1 ) {
                textResponse.addText( "", Optional.of(logger)) ;
            }
        }
    }
}


